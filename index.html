<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grand Theft Orange: Emerald City</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #4a6670; font-family: 'Inter', sans-serif; cursor: crosshair; }
        #ui { position: absolute; top: 20px; left: 20px; pointer-events: none; color: white; text-shadow: 0 2px 4px rgba(0,0,0,0.5); z-index: 10; }
        .wanted-star { font-size: 32px; color: #fff; text-shadow: 0 0 5px rgba(0,0,0,0.5); transition: color 0.3s, text-shadow 0.3s; }
        .wanted-star.active { color: #ef4444; text-shadow: 0 0 15px #ef4444; }
        
        #minimap-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 220px; height: 220px;
            background: #1a1a1a;
            border: 4px solid #064e3b; border-radius: 12px;
            overflow: hidden; z-index: 10;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #minimap-canvas { width: 100%; height: 100%; }

        .screen-overlay {
            position: absolute; inset: 0; background: rgba(0,0,0,0.9);
            display: none; flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 100;
        }
        #instructions {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(6, 78, 59, 0.8); 
            padding: 10px 30px; border-radius: 5px;
            color: #fff; font-size: 12px; text-transform: uppercase; letter-spacing: 1px;
            text-align: center; z-index: 10;
        }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 4px; height: 4px;
            background: white; border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: none; z-index: 20; box-shadow: 0 0 5px rgba(0,0,1);
        }

        .jail-meme-text { font-family: 'Impact', sans-serif; -webkit-text-stroke: 2px black; color: white; text-transform: uppercase; }
        .success-text { font-family: 'Impact', sans-serif; -webkit-text-stroke: 2px #064e3b; color: #10b981; text-transform: uppercase; }
    </style>
</head>
<body>

<div id="crosshair"></div>

<div id="ui">
    <div class="text-5xl font-bold tracking-tighter mb-2 text-white drop-shadow-md">
        <span class="text-orange-400">ORANGES:</span> <span id="score">0</span> / 10
    </div>
    <div id="wanted-level" class="flex gap-1">
        <span class="wanted-star">★</span><span class="wanted-star">★</span><span class="wanted-star">★</span><span class="wanted-star">★</span><span class="wanted-star">★</span>
    </div>
    <div class="text-xs font-mono text-emerald-100 mt-4 border-l-4 border-emerald-500 pl-3 max-w-xs leading-relaxed" id="objective-text">
        LOCATION: DOWNTOWN SEATTLE<br>
        TASK: FIND NPCs WITH ORANGES<br>
        WATCH FOR SPD PATROLS
    </div>
</div>

<div id="minimap-container">
    <canvas id="minimap-canvas"></canvas>
</div>

<div id="instructions">
    WASD: Move <span class="text-orange-400 mx-2">|</span> Shift: Sprint <span class="text-orange-400 mx-2">|</span> Left Click: Punch
</div>

<div id="game-over" class="screen-overlay">
    <h1 class="text-7xl font-black text-white mb-4 italic uppercase jail-meme-text text-center">Believe it or not,<br>Straight to Jail</h1>
    <p class="text-emerald-100 mb-6 text-xl">You stole an orange? Straight to jail.</p>
    <button onclick="location.reload()" class="px-8 py-3 bg-red-600 text-white hover:bg-red-700 transition-all font-mono font-bold uppercase tracking-widest shadow-lg">Retry Run</button>
</div>

<div id="game-win" class="screen-overlay">
    <h1 class="text-7xl font-black mb-4 italic uppercase success-text text-center">Mission Complete</h1>
    <p class="text-emerald-100 mb-6 text-xl">All oranges delivered to PriceCo. The streets are safe.</p>
    <button onclick="location.reload()" class="px-8 py-3 bg-emerald-600 text-white hover:bg-emerald-700 transition-all font-mono font-bold uppercase tracking-widest shadow-lg">Play Again</button>
</div>

<script>
    let scene, camera, renderer, player, clock;
    let leftHand, rightHand;
    let keys = {};
    let npcs = [], police = [], buildings = [], droppedOranges = [];
    let score = 0, wantedLevel = 0, isGameOver = false, isWin = false;
    let punchTimer = 0, punchHand = 0, isPunchingDown = false;
    let pitch = 0, yaw = 0;
    let isRequestingLock = false;
    
    let storeGroup;
    const STORE_POS = new THREE.Vector3(0, 0, 150);

    const CITY_SIZE = 2000;
    const GRID_SIZE = 120;
    const ROAD_WIDTH = 34;
    const NPC_COUNT = 120;
    const POLICE_COUNT = 10;

    function createTex(color1, color2, noise = 0.5) {
        const canvas = document.createElement('canvas');
        canvas.width = 256; canvas.height = 256;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = color1; ctx.fillRect(0,0,256,256);
        for(let i=0; i<5000; i++) {
            ctx.fillStyle = Math.random() > noise ? color1 : color2;
            ctx.fillRect(Math.random()*256, Math.random()*256, 2, 2);
        }
        return new THREE.CanvasTexture(canvas);
    }

    function createRoadTexture(isHorizontal = true) {
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#333333'; ctx.fillRect(0, 0, 512, 512);
        ctx.strokeStyle = '#facc15'; ctx.lineWidth = 6; ctx.setLineDash([40, 20]);
        if (isHorizontal) {
            ctx.beginPath(); ctx.moveTo(0, 252); ctx.lineTo(512, 252); ctx.moveTo(0, 260); ctx.lineTo(512, 260); ctx.stroke();
        } else {
            ctx.beginPath(); ctx.moveTo(252, 0); ctx.lineTo(252, 512); ctx.moveTo(260, 0); ctx.lineTo(260, 512); ctx.stroke();
        }
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        return tex;
    }

    function createWindowTexture(color) {
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = color; ctx.fillRect(0,0,128,128);
        ctx.strokeStyle = '#222222'; ctx.lineWidth = 4;
        for(let i=16; i<128; i+=32) {
            for(let j=16; j<128; j+=32) {
                ctx.strokeRect(i-8, j-8, 16, 16);
                ctx.fillStyle = Math.random() > 0.3 ? '#88ccff' : '#222';
                ctx.fillRect(i-8, j-8, 16, 16);
            }
        }
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(4, 10);
        return tex;
    }

    const grassTex = createTex('#064e3b', '#065f46', 0.4);

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x4a6670); 
        scene.fog = new THREE.FogExp2(0x4a6670, 0.0006);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
        clock = new THREE.Clock();

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambient = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7);
        scene.add(ambient);

        const sun = new THREE.DirectionalLight(0xffffee, 0.9);
        sun.position.set(200, 500, 100);
        scene.add(sun);

        createSeattleLandmarks();
        createPriceCoStore(); 
        createEnvironment();
        createPlayerSetup();
        spawnEntities();

        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);
        window.addEventListener('mousedown', async () => {
            if (document.pointerLockElement) isPunchingDown = true;
            else if (!isRequestingLock && !isGameOver && !isWin) {
                isRequestingLock = true;
                try { await document.body.requestPointerLock(); } catch (e) {} finally { isRequestingLock = false; }
            }
        });
        window.addEventListener('mouseup', () => isPunchingDown = false);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('resize', onWindowResize);

        animate();
    }

    function createPriceCoStore() {
        storeGroup = new THREE.Group();
        
        // Building
        const h = 25;
        const store = new THREE.Mesh(new THREE.BoxGeometry(40, h, 30), new THREE.MeshStandardMaterial({ color: 0xcccccc }));
        store.position.y = h/2;
        storeGroup.add(store);

        // Sign
        const signCanvas = document.createElement('canvas');
        signCanvas.width = 512; signCanvas.height = 128;
        const sctx = signCanvas.getContext('2d');
        sctx.fillStyle = '#ef4444'; sctx.fillRect(0,0,512,128);
        sctx.fillStyle = 'white'; sctx.font = 'bold 80px Impact'; sctx.textAlign = 'center'; sctx.textBaseline = 'middle';
        sctx.fillText('PriceCo', 256, 64);
        const signTex = new THREE.CanvasTexture(signCanvas);
        const sign = new THREE.Mesh(new THREE.PlaneGeometry(25, 6), new THREE.MeshBasicMaterial({ map: signTex }));
        sign.position.set(0, h + 3, 15.1);
        storeGroup.add(sign);

        // Red X Drop Zone
        const xCanvas = document.createElement('canvas');
        xCanvas.width = 256; xCanvas.height = 256;
        const xctx = xCanvas.getContext('2d');
        xctx.strokeStyle = '#ef4444'; xctx.lineWidth = 40;
        xctx.beginPath(); xctx.moveTo(40,40); xctx.lineTo(216,216); xctx.moveTo(216,40); xctx.lineTo(40,216); xctx.stroke();
        const xTex = new THREE.CanvasTexture(xCanvas);
        const xMark = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), new THREE.MeshBasicMaterial({ map: xTex, transparent: true }));
        xMark.rotation.x = -Math.PI/2;
        xMark.position.set(0, 0.05, 25);
        storeGroup.add(xMark);

        storeGroup.position.copy(STORE_POS);
        storeGroup.visible = false;
        scene.add(storeGroup);
        
        buildings.push({minX: STORE_POS.x - 22, maxX: STORE_POS.x + 22, minZ: STORE_POS.z - 17, maxZ: STORE_POS.z + 17});
    }

    function createSeattleLandmarks() {
        const needle = new THREE.Group();
        const shaft = new THREE.Mesh(new THREE.CylinderGeometry(5, 10, 220, 6), new THREE.MeshStandardMaterial({color: 0xcccccc}));
        shaft.position.y = 110;
        const saucer = new THREE.Mesh(new THREE.CylinderGeometry(35, 15, 10, 16), new THREE.MeshStandardMaterial({color: 0xeeeeee}));
        saucer.position.y = 200;
        needle.add(shaft, saucer);
        needle.position.set(300, 0, -450); scene.add(needle);
        buildings.push({minX: 270, maxX: 330, minZ: -480, maxZ: -420});
    }

    function createEnvironment() {
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(CITY_SIZE * 2.5, CITY_SIZE * 2.5), new THREE.MeshStandardMaterial({ map: grassTex }));
        ground.rotation.x = -Math.PI / 2; scene.add(ground);

        const hRoadMat = new THREE.MeshStandardMaterial({ map: createRoadTexture(true) });
        const vRoadMat = new THREE.MeshStandardMaterial({ map: createRoadTexture(false) });

        for(let i = -CITY_SIZE/2; i <= CITY_SIZE/2; i += GRID_SIZE) {
            const hRoad = new THREE.Mesh(new THREE.PlaneGeometry(CITY_SIZE, ROAD_WIDTH), hRoadMat);
            hRoad.rotation.x = -Math.PI/2; hRoad.position.set(0, 0.01, i); scene.add(hRoad);
            const vRoad = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_WIDTH, CITY_SIZE), vRoadMat);
            vRoad.rotation.x = -Math.PI/2; vRoad.position.set(i, 0.01, 0); scene.add(vRoad);
        }

        for (let x = -CITY_SIZE/2 + GRID_SIZE/2; x < CITY_SIZE/2; x += GRID_SIZE) {
            for (let z = -CITY_SIZE/2 + GRID_SIZE/2; z < CITY_SIZE/2; z += GRID_SIZE) {
                // Keep clear for player and store
                if ((Math.abs(x) < 80 && Math.abs(z) < 80) || (Math.abs(x-STORE_POS.x) < 60 && Math.abs(z-STORE_POS.z) < 60)) continue; 
                const h = 40 + Math.random() * 280;
                const w = GRID_SIZE - 50;
                const b = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), new THREE.MeshStandardMaterial({ color: 0x334455, map: createWindowTexture('#222') }));
                b.position.set(x, h/2, z); scene.add(b);
                buildings.push({minX: x-w/2-5, maxX: x+w/2+5, minZ: z-w/2-5, maxZ: z+w/2+5});
            }
        }
        for(let i=0; i<POLICE_COUNT; i++) createPoliceVehicle();
    }

    function createPoliceVehicle() {
        const car = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(4.2, 1.8, 8.5), new THREE.MeshStandardMaterial({color: 0x111111}));
        body.position.y = 1; car.add(body);
        const roof = new THREE.Mesh(new THREE.BoxGeometry(3.4, 1.1, 4.2), new THREE.MeshStandardMaterial({color: 0xffffff}));
        roof.position.set(0, 2.3, -0.2); car.add(roof);
        const l1 = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.3, 0.5), new THREE.MeshStandardMaterial({color: 0xff0000, emissive: 0xff0000}));
        l1.position.set(-0.8, 2.9, -0.2); car.add(l1);
        const l2 = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.3, 0.5), new THREE.MeshStandardMaterial({color: 0x0000ff, emissive: 0x0000ff}));
        l2.position.set(0.8, 2.9, -0.2); car.add(l2);
        car.position.set((Math.random()-0.5)*CITY_SIZE*0.8, 0, (Math.random()-0.5)*CITY_SIZE*0.8);
        scene.add(car); police.push(car);
    }

    function createPlayerSetup() {
        player = new THREE.Group();
        scene.add(player);
        const armMat = new THREE.MeshStandardMaterial({color: 0xffdbac});
        leftHand = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 1.2), armMat);
        leftHand.rotation.x = Math.PI/2; leftHand.position.set(-0.6, -0.5, -0.8);
        camera.add(leftHand);
        rightHand = leftHand.clone(); rightHand.position.x = 0.6;
        camera.add(rightHand);
        camera.position.set(0, 1.7, 0); player.add(camera);
    }

    function onMouseMove(e) {
        if (document.pointerLockElement === document.body) {
            yaw -= e.movementX * 0.002;
            pitch -= e.movementY * 0.002;
            pitch = Math.max(-Math.PI/2.1, Math.min(Math.PI/2.1, pitch));
            camera.rotation.set(pitch, yaw, 0, 'YXZ');
        }
    }

    function createHumanNPC() {
        const npc = new THREE.Group();
        const skinColor = [0xffdbac, 0x8d5524, 0xc68642, 0xe0ac69, 0xf1c27d][Math.floor(Math.random()*5)];
        const shirtColor = Math.random() * 0xffffff;
        const pantsColor = Math.random() * 0x444444;

        const torso = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.1, 0.4), new THREE.MeshStandardMaterial({color: shirtColor}));
        torso.position.y = 1.35; npc.add(torso);
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.45, 0.45), new THREE.MeshStandardMaterial({color: skinColor}));
        head.position.y = 2.15; npc.add(head);

        const legGeom = new THREE.BoxGeometry(0.3, 0.8, 0.3);
        const legMat = new THREE.MeshStandardMaterial({color: pantsColor});
        const leftLeg = new THREE.Mesh(legGeom, legMat); leftLeg.position.set(-0.2, 0.4, 0); npc.add(leftLeg);
        const rightLeg = new THREE.Mesh(legGeom, legMat); rightLeg.position.set(0.2, 0.4, 0); npc.add(rightLeg);
        
        npc.leftLeg = leftLeg; npc.rightLeg = rightLeg;
        npc.hasOrange = Math.random() > 0.4;
        npc.isDead = false;
        npc.walkCycle = Math.random() * Math.PI * 2;
        
        if (npc.hasOrange) {
            const orangeGeo = new THREE.SphereGeometry(0.2, 8, 8);
            const orangeMat = new THREE.MeshStandardMaterial({color: 0xffa500, emissive: 0xaa5500});
            const heldOrange = new THREE.Mesh(orangeGeo, orangeMat);
            heldOrange.position.set(0.4, 1.3, 0.3); npc.add(heldOrange);
            npc.heldOrange = heldOrange;
        }
        
        npc.state = 'wander'; 
        npc.stateTimer = Math.random() * 5;
        npc.targetAngle = Math.random() * Math.PI * 2;
        return npc;
    }

    function spawnEntities() {
        for (let i = 0; i < NPC_COUNT; i++) {
            const npc = createHumanNPC();
            let pos;
            let attempts = 0;
            do {
                pos = new THREE.Vector3((Math.random()-0.5)*CITY_SIZE*0.8, 0, (Math.random()-0.5)*CITY_SIZE*0.8);
                attempts++;
            } while (checkCollision(pos) && attempts < 20);
            npc.position.copy(pos);
            npcs.push(npc); scene.add(npc);
        }
    }

    function drawMinimap() {
        const canvas = document.getElementById('minimap-canvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        canvas.width = 220; canvas.height = 220;
        ctx.fillStyle = '#064e3b'; ctx.fillRect(0,0,220,220);
        const ZOOM = 10;
        const mapX = (v) => (v - player.position.x) / ZOOM + 110;
        const mapY = (v) => (v - player.position.z) / ZOOM + 110;

        ctx.fillStyle = '#333';
        for(let i = -CITY_SIZE/2; i <= CITY_SIZE/2; i += GRID_SIZE) {
            ctx.fillRect(0, mapY(i - ROAD_WIDTH/2), 220, ROAD_WIDTH/ZOOM);
            ctx.fillRect(mapX(i - ROAD_WIDTH/2), 0, ROAD_WIDTH/ZOOM, 220);
        }

        const pulse = (Math.sin(Date.now() * 0.01) + 1) * 2 + 4;
        police.forEach(p => {
            ctx.fillStyle = '#ff0000';
            ctx.beginPath(); ctx.arc(mapX(p.position.x), mapY(p.position.z), pulse, 0, Math.PI*2); ctx.fill();
        });

        if (score < 10) {
            ctx.fillStyle = '#ffa500';
            npcs.forEach(n => { if(n.hasOrange && !n.isDead) { ctx.beginPath(); ctx.arc(mapX(n.position.x), mapY(n.position.z), 3, 0, Math.PI*2); ctx.fill(); } });
        } else {
            // Objective marker
            ctx.fillStyle = '#ef4444';
            ctx.beginPath(); ctx.arc(mapX(STORE_POS.x), mapY(STORE_POS.z + 25), pulse * 1.5, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.stroke();
        }

        ctx.save(); ctx.translate(110, 110); ctx.rotate(-yaw); ctx.fillStyle = '#10b981';
        ctx.beginPath(); ctx.moveTo(0, -7); ctx.lineTo(6, 7); ctx.lineTo(-6, 7); ctx.closePath(); ctx.fill();
        ctx.restore();
    }

    function checkCollision(pos) {
        let hit = false; const r = 1.2;
        buildings.forEach(b => { if (pos.x > b.minX - r && pos.x < b.maxX + r && pos.z > b.minZ - r && pos.z < b.maxZ + r) hit = true; }); 
        return hit;
    }

    function update() {
        if (isGameOver || isWin) return;
        const delta = clock.getDelta();

        // Punching logic
        if (isPunchingDown && punchTimer <= 0) {
            punchTimer = 0.25; punchHand = 1 - punchHand;
            npcs.forEach(n => {
                if (!n.isDead && player.position.distanceTo(n.position) < 8) {
                    n.isDead = true; n.rotation.x = -Math.PI/2; n.position.y = 0.4;
                    if(n.heldOrange) n.heldOrange.visible = false;
                    if (n.hasOrange) {
                        const o = new THREE.Mesh(new THREE.SphereGeometry(0.35, 8, 8), new THREE.MeshStandardMaterial({color: 0xffa500, emissive: 0x331100}));
                        o.position.copy(n.position); o.position.y = 0.5; droppedOranges.push(o); scene.add(o);
                        if(wantedLevel < 5) { wantedLevel++; document.querySelectorAll('.wanted-star')[wantedLevel-1].classList.add('active'); }
                    }
                }
            });
        }
        if (punchTimer > 0) {
            punchTimer -= delta;
            const offset = Math.sin((0.25 - punchTimer) * Math.PI / 0.25) * 1.5;
            if (punchHand === 0) leftHand.position.z = -0.8 - offset;
            else rightHand.position.z = -0.8 - offset;
        }

        // NPC AI
        npcs.forEach(n => {
            if (n.isDead) return;
            n.stateTimer -= delta;
            if (n.stateTimer <= 0) {
                n.state = n.state === 'wander' ? 'idle' : 'wander';
                n.stateTimer = 2 + Math.random() * 5;
                if (n.state === 'wander') n.targetAngle = Math.random() * Math.PI * 2;
            }
            if (n.state === 'wander') {
                const speed = 4;
                const nextPos = n.position.clone();
                nextPos.x += Math.sin(n.targetAngle) * speed * delta;
                nextPos.z += Math.cos(n.targetAngle) * speed * delta;
                if (!checkCollision(nextPos)) { n.position.copy(nextPos); } 
                else { n.targetAngle += Math.PI; n.stateTimer = 0.5; }
                n.rotation.y = n.targetAngle;
                n.walkCycle += delta * 10;
                n.leftLeg.rotation.x = Math.sin(n.walkCycle) * 0.5;
                n.rightLeg.rotation.x = Math.sin(n.walkCycle + Math.PI) * 0.5;
            }
        });

        // Player Movement with sliding collisions
        let ix = 0, iz = 0;
        if (keys['KeyW']) iz -= 1; if (keys['KeyS']) iz += 1;
        if (keys['KeyA']) ix -= 1; if (keys['KeyD']) ix += 1;
        if (ix || iz) {
            const dir = new THREE.Vector3(ix, 0, iz).normalize().applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
            const moveMagnitude = (keys['ShiftLeft'] ? 55 : 20) * delta;
            const moveVec = dir.multiplyScalar(moveMagnitude);
            const nextX = player.position.clone().add(new THREE.Vector3(moveVec.x, 0, 0));
            const nextZ = player.position.clone().add(new THREE.Vector3(0, 0, moveVec.z));
            if (!checkCollision(nextX)) player.position.x = nextX.x;
            if (!checkCollision(nextZ)) player.position.z = nextZ.z;
        }

        // Police Chase
        police.forEach(p => {
            if(wantedLevel > 0) {
                const dir = new THREE.Vector3().subVectors(player.position, p.position).normalize();
                const move = dir.multiplyScalar((15 + wantedLevel * 5) * delta);
                const nextPX = p.position.clone().add(new THREE.Vector3(move.x, 0, 0));
                const nextPZ = p.position.clone().add(new THREE.Vector3(0, 0, move.z));
                if(!checkCollision(nextPX)) p.position.x = nextPX.x;
                if(!checkCollision(nextPZ)) p.position.z = nextPZ.z;
                p.lookAt(player.position);
                if(p.position.distanceTo(player.position) < 7) { 
                    isGameOver = true; document.getElementById('game-over').style.display = 'flex'; 
                    if (document.pointerLockElement) document.exitPointerLock(); 
                }
            }
        });

        // Orange Collection
        for (let i = droppedOranges.length-1; i>=0; i--) {
            droppedOranges[i].rotation.y += delta * 2;
            if (player.position.distanceTo(droppedOranges[i].position) < 4) {
                scene.remove(droppedOranges[i]); droppedOranges.splice(i, 1);
                score++; document.getElementById('score').innerText = score;
                if (score === 10) {
                    storeGroup.visible = true;
                    document.getElementById('objective-text').innerHTML = "DELIVER TO PRICECO<br>LOCATION: RED MARKER ON MINIMAP";
                }
            }
        }

        // Drop-off logic
        if (score >= 10) {
            const dropXPos = new THREE.Vector3(STORE_POS.x, 0, STORE_POS.z + 25);
            if (player.position.distanceTo(dropXPos) < 6) {
                isWin = true; document.getElementById('game-win').style.display = 'flex';
                if (document.pointerLockElement) document.exitPointerLock();
            }
        }

        drawMinimap();
    }

    function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
    function animate() { requestAnimationFrame(animate); update(); renderer.render(scene, camera); }
    window.onload = init;
</script>
</body>
</html>